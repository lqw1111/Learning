线程池
1）线程池状态
ThreadPoolExecutor使用int的高3位来便是线程状态，低29位表示线程数量

状态                  接受新任务       处理阻塞队列任务
RUNNING     111         Y               Y
SHUTDOWN    000         N               Y               不接受新任务，但会处理阻塞队列剩余任务
STOP        001         N               N               不中断正在执行的任务，并抛弃阻塞队列任务
TIDYING     010                                         任务全执行完毕，活动线程位0即将进入终结
TERMINATED  011                                         终结状态

线程池构造
corePoolSize 核心线程数亩（最多保留的线程数）
maximumPoolSize 最大线程数 （maximumPoolSize - corePoolSize = 救急线程数）
keepAliveTime 生存时间 （救急线程生存时间）
unit 时间单位
workQueue 阻塞队列
threadFactory 线程工程-可以为线程创建时起个好名字
handle 拒绝策略


救急线程 发生在并发量突然增多，阻塞队列不够用的时候，就会用救急线程
救急线程有生存时间，在任务结束后就消失

拒绝策略
AbortPolicy         让调用者跑出RejectedExecutionException异常，这是默认策略
CallerRunsPolicy    让调用者运行任务
DiscardPolicy       放弃本次任务
DiscardOldestPolicy 放弃任务队列中最早的任务，本任务取而代之

Dubbo的实现，在抛出RejectedExcecutionException异常之前会记录日志，并dump线程占信息，方便定位问题
Netty的实现，是创建一个新线程来执行任务
ActiveMQ的实现，带超时等待(60s)尝试放入队列，类似我们之前自定义的拒绝策略
PinPoint的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略

------------------------------------------------------------------------------------------------------------------------
newFixedThreadPool
特点：核心线程数 == 最大线程数，因此也无需超时时间
阻塞队列是无界的，所有可以放任意数量的任务

适用于任务量已知，相对耗时的任务

------------------------------------------------------------------------------------------------------------------------
newCachedThreadPool
特点：
核心线程数是0，最大线程数是Integer.MAX_VALUE,救急线程的空闲生存时间是60s,意味着
    全部都是救急线程(60s后可以回收）
    救急线程可以无限创建
队列采用了SynchronousQueue实现特点是，它没有容量，没有线程来去是放不进去的(一手交钱，一手交货）

整个线程池表现为线程数会根据任务量不断增长，没有上线，当任务执行完毕，空闲1分钟后释放线程。
是和任务数比较密集，但每个任务执行时间较短的情况。

------------------------------------------------------------------------------------------------------------------------
newSingleThreadExecutor
使用场景：
希望多个任务排队执行。线程数固定为1，任务数多于1时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。

区别：
1）自己创建一个线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作。
2）Executors.newSingleThreadExecurot() 线程个数始终为1，不能修改
    FinalizableDelegatedExecutorService 应用的是装饰器模式，对外只暴漏了ExecutorService接口，因此不能调用ThreadPoolExecutor
    中的特有方法
    也就是说在这个装饰器模式下，只有暴漏接口的方法，而实例对象的特有方法不能访问。对于newFixedThreadPool，直接可以修改线程池的属性，
    但线程执行器就不可以。
3）Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改
    对外暴漏的是ThreadPoolExecutor对象，可以强转后调用setCorePoolSize等方法进行修改。
    对于newFixedThreadPool

invokeAll():返回一个Future的list
invokeAny():返回第一个返回的结果

------------------------------------------------------------------------------------------------------------------------
关闭线程池的方法：
shutdown:线程池状态变为SHUTDOWN。不会接受新任务，但已经提交任务会执行完，此方法不会阻塞调用线程的执行

shutdownNow: 线程池状态变为STOP，不会接受新任务，会将队列重的任务返回，并用interrupt的方式中断正在执行的任务

isShutdown(): 不再RUNNING 状态的线程池，此方法就返回true

isTerminated():线程池状态是否是TERMINATED

awaitTermination(long timeout, TimeUnit unit): 调用shutdown后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池
                            TERMINATED后做些事情，可以利用此方法等待。

------------------------------------------------------------------------------------------------------------------------

异步模式之工作线程
1。定义
让有限的工作线程来轮流异步处理无限多的任务，也可以将其归类为分工模式，他的典型实现就是线程池，也体现了经典设计模式中的享元模式。
比如海底捞的服务员，轮流处理客户的点餐任务
逐一，不同任务类型应该使用不同的线程池，这样能够避免界，并能提升效率

2。饥饿
使用固定大小的线程池，会有饥饿现象
两个工人是同一个线程池中的两个线程，
他们要做的事情是：为客人点餐和到后厨做菜，这是两个阶段的工作
    客人点餐：必须先点完餐，等菜做好，上菜，在此期间处理点餐的工人必须等待
    后厨做菜：没啥说的。做就完事

------------------------------------------------------------------------------------------------------------------------
创建多少线程池合适
1。过小会导致程序不能充分的利用系统资源，容易导致饥饿
2。过大会导致更多的线程上下文切换，占用更多的内存

3.1 CPU密集型运算
通常采用cpu核数 + 1能够实现最有的CPU利用率，+1是保证当线程由于页缺失（操作系统）或其他原因导致暂停时，额外的这个线程就能顶上去，保证CPU
时钟周期不被浪费。

3.2 I/O密集型运算
CPU不总是处于繁忙状态，例如，当你执行业务计算时候，这时候会使用CPU资源，但当你执行IO操作时候，远程RPC调用时，包括进行数据库操作时，这时候
CPU就闲下来了，你可以利用多线程提高它的利用率。
公式：
线程数 = 核数 * 期望CPU 利用率 * 总时间(cpu计算时间+等待时间）/CPU计算时间

例如4核CPU计算时间是50%，其他等待时间50%，期望cpu被利用100%，
4 * 100% * 100% / 50% = 8

------------------------------------------------------------------------------------------------------------------------
任务调度线程池
在任务调度线程池加入之前，使用的是Timer，Timer的有点事简单，但由于所有任务都是由一个线程调度，所以是串行的，所以效率低下。

------------------------------------------------------------------------------------------------------------------------
Tomcat线程池

------------------------------------------------------------------------------------------------------------------------

1、AQS原理
全称是 AbstractQueuedSynchronizer,是阻塞式锁和相关的同步器工具的框架
特点：
(1)用state属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁
    getState - 获取state状态
    setState - 设置state状态
    compareAndSetState - 乐观锁机制设置state状态
    独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源
(2)提供了基于FIFO的等待队列，类似于Monitor的EntryList
(3)条件变量来实现等待、唤醒机制，支持多个条件变量，类似于Monitor的WaitSet

------------------------------------------------------------------------------------------------------------------------
条件变量原理

------------------------------------------------------------------------------------------------------------------------
2、读写锁的使用
让读读可以并发，读写互斥

读锁不支持条件变量
重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待

------------------------------------------------------------------------------------------------------------------------
读写锁原理
读写锁用的是同一个Sycn同步器，因此等待队列，state等也是同一个

------------------------------------------------------------------------------------------------------------------------
信号量：用来限制同时能访问共享资源的线程上线

Semaphore应用
    1、使用Semaphore限流，在访问高峰期时候，让请求线程阻塞，高峰期过去再释放许可，当然它只适合限制单机线程数量，并且仅是限制线程数，
    而不是限制资源数量。
    2、简单的连接池

------------------------------------------------------------------------------------------------------------------------
Semaphore原理

------------------------------------------------------------------------------------------------------------------------
线程安全类

jdk7 并发死链问题

------------------------------------------------------------------------------------------------------------------------
LinkedBlockingQueue与ArrayBlockingQueue的性能比较
    Linked支持有界，Array强制有界
    Linked实现是链表，Array是数组
    Linked是懒惰的，而Array需要提前初始化Node数组
    Linked每次入队会生成新Node，而Array的Node是提前创建好的
    Linked两把锁，Array一把锁


在CopyOnWriteArrayList上面get存在弱一致性
迭代器弱一致性

弱一致性并不是不好，需要权衡，高并发和一致性是矛盾的
数据库的MVCC都是弱一致性的表现