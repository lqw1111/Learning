六、共享模型之无锁
CAS与volatile
原子整数
原子引用
原子累加器
Unsafe


6.1、问题引出
CAS底层是lock cmpxchg指令（x86架构），在单核CPU和多核CPU下都能保证原子性
在多核状态下，某个核执行到带lock的指令时，CPU会让总线锁住，当这个核吧此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，
保证了多个线程对内存操作的准确性，是原子的。

------------------------------------------------------------------------------------------------------------------------
volatile和cas
获取共享变量的时候，为了保证该变量的可见行，需要使用volatile修饰。
它可以用来修饰成员变量和静态成员变量

------------------------------------------------------------------------------------------------------------------------
为什么无锁效率高
无锁情况下，即使重试失败，线程始终在告诉运行，没有停歇，而synchronized会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。
但无锁情况下，因为线程要保持运行，需要额外CPU的支持，CPU在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会
进入阻塞，但由于没有分时时间片，仍然会进入可运行状态，还是会导致上下文切换

CAS特点
结合CAS和volatile可以实现无锁并发，适用于线程数少、多核CPU的场景下
1、CAS是基于乐观锁的思想，最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我再重试一次
2、synchronized是基于被关锁的思想：最被关的估计，得防着其他线程来修改共享变量，我上了锁你们都别想改，我改完了锁开锁，你们才有机会
3、CAS体现的是无锁并发，无阻塞并发
    因为没有使用Synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一
    如果竞争激烈，可以想到重试鼻炎频繁发生，反而效率会受影响

------------------------------------------------------------------------------------------------------------------------
CAS的ABA问题
可以使用AtomicStampReference解决
------------------------------------------------------------------------------------------------------------------------
AtomicMarkableReference
如果你只关心是不是被修改过，就用AtomicMarkableReference就可以

supplier 提供者 () -> 结果
function 函数   一个参数一个结果      (参数) -> 结果， BiFunction (参数1，参数2) -> 结果
consumer 消费者 一个参数没有结果      (参数) -> void, BiConsumer  (参数1，参数2) -> void

字段更新器
AtomicReferenceFieldUpdater
AtomicIntegerFieldUpdater
AtomicLongFieldUpdater

LongAdder会比AtomicLong效率更好
性能提升的原因很简单，就是在有竞争的时候，设置多个累加单元，Thread-0累加Cell[0]，而Thread-1累加Cell[0]，最后把结果汇总，这样他们在累加
的时候操作的不同Cell变量，因此减少了CAS重试失败，从而提高性能。

------------------------------------------------------------------------------------------------------------------------
LongAdder源码

@sun.misc.Contended 防止缓存行伪共享

------------------------------------------------------------------------------------------------------------------------
unsafe对象
Unsafe对象提供了非常底层的，操作内存，线程的方法，Unsafe对象不能直接调用，只能通过反射获得