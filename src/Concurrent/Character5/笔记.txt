五、共享模型

java内存模型
在java方面定义了主存，工作内存，底层对应着CPU寄存器，缓存，硬件内存，CPU指令优化

JMM体现在一下几个方面
原子性
可见性
有序性

------------------------------------------------------------------------------------------------------------------------
划分为主存和工作内存
JIT会对代码进行优化，当从主存中数据读入到线程之后，读入的变量，会放在线程自己的工作内存中

所以为了解决这种工作内存和主存的不可见的问题，所以引入了valatile这个关键字
如果使用了这个关键字，那么JIT便不会使用这种优化，而是每一次都对在主存中读取到需要获取的值

volatile: 它可以用来修饰成员变量和静态成员变量，它可以避免线程从自己的工作缓存中查找变量的值，必须要主存中获取它的值，
线程操作volatile变量都是直接操作主存

使用synchronized也可以保证变量的可见行

volatile更轻量，如果只是改变可见行，推荐使用volatile

------------------------------------------------------------------------------------------------------------------------

volatile可以保证可见行，但是不能保证原子性
它只能保证看到的是最新的值，但是不能解决指令交错的事情，也就说对于多个线程同时的写，就不能保证同步

------------------------------------------------------------------------------------------------------------------------
3、有序性
JVM会在不影响正确性的前提下，可以调整语句的执行顺序
这种特性称为"指令重排"，多线程下指令重排会影响正确性

使用了volatile可以禁止指令的重排序，使用了volatile之后，变量之前的代码是不会重排序的

jdk并发压测试 jcstress
------------------------------------------------------------------------------------------------------------------------

4、volatile原理
volatile的底层实现原理是内存屏障，Memory Barrier(Memory Fence)
    对volatile变量的写指令后会加入写屏障
    对volatile变量的读指令后会加入读屏障

写屏障(sfence)保证在该屏障之前的，对共享变量的改动，都同步到主存当中

读屏障(lfence)保证在该屏障之后的，对共享变量的读取，加载的是主存中最新数据

volatile依然不能解决对线程之间的指令交错的问题，volatile只能解决有序和可见，但是不能保证原子

------------------------------------------------------------------------------------------------------------------------

double checked locking 方法在多线程下的问题
可能由于在多线程的环境下，jvm会对指令进行重排序，这时候，由于第一个地方的 if(INSTANCE == null) 发现不为空
但是由于指令的重排序，导致了构造函数的引用还没有执行，也就是没有执行构造方法，出现了问题。
这时候t2线程拿到的就是一个还没有实现完构造的单例

synchronized并不能阻止指令的重排序，volatile会保证重排序问题
但是如果synchronized的代码块中的代码，完全由synchronized管理的时候，是不会有顺序问题的

double checked locking中设计的问题，完全是由于synchronized没有完全的保护这一代码块，他们有外部的共享变量，所以产生了问题

解决double checked locking的问题：给INSTANCE变量上加上volatile，保证不会发生重排序

读屏障会防止读操作之后的代码重排到读操作之前，写屏障是防止写操作之后的代码重排到写之后去

------------------------------------------------------------------------------------------------------------------------
happens-before
happens-before规定了对共享变量的写操作对其他线程的读操作可见，它是可见行与有序性的一套规则总结，抛开happens-before规则，JMM并不能
保证一个线程对共享变量的写，对于其他线程对该共享变量的读可见

线程解锁m之前对变量写
1、使用synchronized
2、使用volatile变量的写，对其他读线程操作可见
3、线程start前对变量的写，在start之后的读操作是可见的
4、线程结束前对变量的写，对于其他线程得知它结束后的读是可见的（比如调用t.isAlive()或者t.join()操作之后)
5、线程t1打断t2前对变量的写，对于其他线程得知t2被打断后对变量的读可见
6、对变量某人只(0,false,null)的写，对其他线程对该变量的读可见
7、具有传递性，如果x hb -> y 并且y hb -> z那么有x hb -> z,配合volatile的防指令重排，有下面的例子


------------------------------------------------------------------------------------------------------------------------
单例线程安全问题
1、单例为啥加final
    将来怕子类不适当的方法，破坏单例，由于可见行等问题引起
2、如果实现了序列化接口，还要做什么来防止反序列化破坏单例
    因为反序列化之后，又会重新提供一个新的对象，这个会破坏单例
    如何修正，在对象中加一个readSolve方法，返回INSTANCE，readSolve会查看，在反序列化之后，就使用这个方法返回实例
3、为什么设置为私有，能不能防止反射创建新的实例
    反射不可防止
4、使用静态成员变量创建单例是否有线程安全
    没有线程安全问题，因为静态成员变量是由JVM控制的，JVM会帮助控制线程安全问题
5、为什么提供静态方法而不是直接把INSTANCE设置为public
    1）使用方法可以提供更好的封装
    2）创建单例对象有更多的控制
    3）支持范型

------------------------------------------------------------------------------------------------------------------------
1、枚举单例是如何限制实例的个数的
    反编译之后我们可以发现枚举类是使用final static的一个instance
2、枚举单例在创建时候是否有并发问题
    没有，因为是静态成员变量
3、枚举单例能否被反射破坏单例
    不能
4、枚举单例能否被反序列化破坏单例
    枚举类都是默认实现了反序列化接口的，在实现的时候，已经考虑过这个问题，所以不需要自己实现
5、枚举单例属于懒汉式还是饿汉式
    饿汉式
6、枚举单例如果希望加入一些单例创建时的初始化逻辑应该怎么做
    加一个构造方法，在构造方法中实现

------------------------------------------------------------------------------------------------------------------------
懒汉式单例有什么问题
如果使用了synchronized，每次都要加锁，所以性能不好

使用静态内部类的好处也是在类加载的时候，在使用的时候，才会进行类加载，所以是懒汉式的加载，所以没有并发问题

------------------------------------------------------------------------------------------------------------------------
总结

JMM中
可见行，是由于JVM缓存优化导致可见行问题
有序性，是由JVM指令优化导致重排序的问题，引起的线程安全问题

CPU指令并行
volatile原理

两阶段模式的volatile改进
同步模式之balking模式