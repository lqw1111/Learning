Monitor概念
32位虚拟机
Mark Word Word

Klass Word:指针，用来找到类对象
普通对象
Klass Word:
Mark Word(32bit) : hash code        :25
                   age              :4
                   biased_lock      :0 | 01

数组对象 (96bit)
Klass Word:
Mark Word(32bit) :
length :

对象大小：
int 4
Integer 8 + 4
所以内存敏感的时候用int

Monitor工作原理
每个java对象都关联一个Monitor对象，如果使用synchronized给对象上锁（重量级）之后，该对象头的Mark Word中就被设置只想Monitor对象的指针
synchronized之后，obj就会记录Monitor对象的地址

Monitor中有
WaitSet,EntryList,Owner
------------------------------------------------------------------------------------------------------------------------

hashCode方法会禁用一个对象的偏向锁，同时，如果两个线程同时访问一个对象，产生竞争状态，则这个对象的偏向锁业户

锁对象最好都是final，因为final之后他的引用不会变，以防以后引用改变之后产生的危险

------------------------------------------------------------------------------------------------------------------------

4、重新理解状态转换
start就是由new 变成了runnable

runnable -> waiting

------------------------------------------------------------------------------------------------------------------------
死锁
为了增加并发度，会增加锁的粒度，但是在增加并发度的同时，会发生死锁

定位死锁
1.使用jps查看进程，然后用jstack <进程号> 查看死锁
2.使用jconsole查看

使用顺序加锁的方式来解决死锁问题

使用线程优先级的问题 会造成线程饥饿问题

------------------------------------------------------------------------------------------------------------------------
ReentrantLock相对于synchronized具备如下特点：
1.可中断
2.可以设置超时时间
3.可以设置为公平锁
4.可以支持多个条件变量
与synchronized一样，都支持可重入

获取锁 reentrantLock.lock();
try{
    //临界区
} finally {
    //释放锁
}

reentranLock和synchronized都是可重入的
------------------------------------------------------------------------------------------------------------------------

公平锁一般是用来解决饥饿问题的，但是会降低并发度，所以使用reentranLock中的tryLock更好

